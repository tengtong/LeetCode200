package algorithm.greedy;

/**
 * 贪心
 * 保证每次操作都是局部最优（贪心），并且最后得到的结果都是全局最优的
 */

import java.util.Arrays;

/**
 * 分配饼干
 * 每个孩子都一个满足度grid，每个饼干都有一个大小size，只有饼干的大小 大于等于 一个孩子的满足度，该孩子才会满足，求解最多可以获得满足的孩子数量
 *
 * 输入: g = [1,2,3], s = [1,1]
 * 输出: 1
 * 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足，所以你应该输出1
 *
 * 思路：
 * 1.给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大的饼干才能拿来给满足度大的孩子
 * 2.因为满足度小的孩子最容易满足，所以先满足最满足度小的孩子
 *
 * 我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。
 * 我们假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比我们使用的贪心策略更优的最优策略。
 * 如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。
 * 证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。
 * 假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m < n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。
 * 因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。
 */
//TODO
public class FindContentChildren {
    public int findContentChildren(int[] grid, int[] size) {
        if (grid == null || size == null) {
            return 0;
        }
        Arrays.sort(grid);
        Arrays.sort(size);
        int gi = 0, si = 0;
        while (gi < grid.length && si < size.length) {
            if (grid[gi] <= size[si]) {
                gi++;
            }
            si++;
        }
        return gi;
    }
}
